---
layout: post
title: Interview Q&A
---

## 1、线程间的互斥锁在操作系统中是如何实现的？

维基百科中对于[互斥锁](!http://zh.wikipedia.org/wiki/互斥锁)这个此条的解释已经很清楚的说明了这个问题。首先需要明白什么是互斥锁，并且在什么场景中需要使用它。

* 互斥锁（Mutual exclusion，缩写Mutex）是一种用于多线程编程中，防止两条线程*同时*对*同一公共资源*（比如全局变量）进行读写的机制。
* 需要此机制的资源的例子有：旗标、队列、计数器、中断处理程序，以及诸如此类的用于在多条并行运行的代码间传递数据、同步状态等的资源。

通过将代码切成一个一个的临界区域（critical section）来达到互斥的目的。临界区域指的是对公共资源进行访问的代码，并非一种机制或是算法。

实现着可分为：

* 硬件实现
* 软件实现


###### 硬件实现

单核心系统上最常见的方式就是尽可能多的关闭可能对共享数据段进行读写的指令中断。这样一来就可以避免在临界区域中暂停程序执行，或是来自硬件的要求修改目标共享数据段的中断请求。

多核心系统上则通过检查并置位机制来达成，当一个核心需要另一个核心占用的资源的时候，该核心将不断的查询所有核心间共享的占用旗标，直到其它核心将旗标复位为未使用为止。如下伪代码：
	
	while (test_and_set(lock) == 1)
		;
		
lock的值为1表示锁被占用，为0则是空闲。

在检查并置位机制中，一个核心在对旗标执行读写的过程当中不会释放占用的访问总线，这种方法又称为*自旋锁*。

###### 软件实现

软件会模拟上面硬件的方式，但是这种模拟会对计算机造成极大的负荷，因为申请占用自旋锁的过程中会不间断地对一个标志位进行读写，并且这种模拟不允许乱序执行，因为这会破坏其机制。

常见的方式是使用操作系统提供的互锁库，这种库通常设计为在有硬件支持时使用硬件机制，否则才使用软件模拟，并且结合线程调度对锁性能进行优化。比如，一个线程要使用一个已经被占用的锁，操作系统选择将这个线程挂起，然后切换上下文到另外一个可以继续运行的线程，若是没有别的线程要继续运行的话，系统就让处理器进入低功耗状态，而不是让这个线程消耗大量处理能力进行自旋来等待锁释放。


## 2、有向图中的两点的最短距离算法？

pass


## 3、python中的classmethod 和 staticmethod ？

pass


## 4、python 装饰器如何写？wrapper是如何实现的？

pass


## 5、python 参数的传递方式，传引用还是传值？

Python和其他语言的工作机制不同，并不涉及传值和传引用这回事，如果非要往这两个概念上靠，那么更接近于传引用。在Python中所有的东西都是object，当在函数中传递参数的时候，实际上是将参数的name挂到了响应的object上，并不在内存中复制object。说“接近于”是因为准确上来说并不是这样的，在其他语言中，传引用意味着能通过参数更改相应的值，但是在Python中，这只适用于可变对象（如list, dict, set等）。如果传过去的对象是不可变对象（如string, int, tuple等），在函数中是不能更改的。


## 6、如何求一个集合中的所有子集？

pass

## 7、字节序列的大小端问题

pass

## 8、网络层次模型，tcp/ip 协议族

pass

## 9、 进程、线程、协程、轻量级进程

pass

## 10、求一个集合里边的所有子集, python 实现

pass

## 11、阻塞和非阻塞如何定义？同步与异步如何定义及其优缺点？

pass
