---
layout: post
title: Everyday Algorithm
---


### 基础数据结构

##### 链表

链表由一连串的元素（成为节点）构成。每个节点包含要存储的数据项以及一个指针，它指向链表中的下一个节点。当程序读取每个数据项时，将创建一个新的节点（使用malloc()函数），必将其添加到链表的尾部。在输入结束时，计算机内存中将维护一个节点列表，其中每个节点都包含数据项（例如城市名称和气温信息）以及指向下一个节点的指针。每个节点中的指针称为*链*（link），因此将这种数据结构称为*链表*（linked list）。每个链表都以一个简单的指针开始，它指向链表中的第一个数据项，这个指针称为*头指针*（head）。

	struct Node {
			char *City;
			int Temp;
			struct Node *Next;
		};
		
	typedef struct Node * Link;
	
	Link Head;
	
创建typedef是为了增强代码可读性。“链”是指向“节点”的指针。我们定义的第一个“链”是“头指针”，当链表为空时它是NULL，否则它指向第一个节点。
初始化一个这种类型的新链表只需要简单的初始化合适的变量：
	
	Head = NULL;
	NodeCount = 0;
	
一旦添加了第一个节点，头指针将指向它。添加节点可能很容易或者是乏味的。如果在添加节点时无需考虑他们在链表（无序链表）中所占据的位置，可以简单的将节点*添加在链表头部*。当为每个节点都分配了空间是，它的“链”将指向当前“头指针”，然后更新“头指针”以指向新的“节点”。

对于有序链表，向其中添加节点需要做更多的的工作：

* 提供比较节点数据的方式，以及确定哪个节点在链表中处于更高或更低的位置
* 确定如何处理新节点与现有节点重复的问题：是应该添加新节点、丢弃新节点，还是修改现有节点数据。

程序清单2-1通过定义两个函数来执行这些任务，这样就可以执行添加节点的实际工作了：

* NodeCmp()
* DuplicateNode()

在遍历链表时，仅当经过插入点或者已经到达链表尾部是。才能知道已经到了添加节点的位置。因此，将需要保存前一个被检查的节点地址。插入发生在当前被检查的节点和前一个节点之间：
	
	prev->Next = pn; 	/* prev must now point to pn */
	pn->Next = curr; 	/* and pn must now point to curr */
	
为了简化设计，程序中可以创建一个*虚拟节点*，并使当前链表从该节点延续下来。这样，链表就永远不会为空，实现的逻辑也将大大简化。程2-1从数据文件中读取城市和气温的信息，将记录插入到一个链表中（按气温和城市名称的升序排序），丢弃重复的记录，然后打印该有序链表，并指示位于中间的条目。数据记录是文本文件中简单的行，前三个字符表示气温，气候接着最多124个字符表示城市名称。
注意：如果不使用链表这样的动态结构，在不读取数据*两边*的情况下，将不可能确定出中间的气温。最后一个循环用于打印链表中的记录，它显示了*遍历*链表有多简单。

##### 双向链表

双向链表使用的节点包含数据以及指向前一个和后一个节点的链。由于经常在链表商执行双向遍历，因此在双向链表的实现中建议定义一个额外的指针，用于跟踪链表中的最后一个节点。该指针称为*尾指针*（tail），它具有与头指针相同的功能————但是位于链表的尾部。
为了避免操作双向链表的过程中出错，一些优秀的程序员通常都有一组*通用的例程*，并且总是使用他们来实现双向链表。
具体例程见[代码部分](https://github.com/stillzhl/algorithm)。


##### 链表的其他特征

无论何时需要在内存中存储*数量不确定*的数据项时，采用动态数据结构很可能是最佳的方法。
使用链表的最大不便是他们的潜在*长度*。搜索一个很长的链表可能很费时，而且如果不得不重复搜索很长的链表，其代价可能变得令人无法忍受。有多种技术可以用来减小开销：
	
* 在链表中以某种顺序放置节点，这样当你想确定链表中是否包含给定节点时，将不需要检查整个链表；
* 将最近访问的节点放到链表头部，这利用*时间局部性*——一旦操作了一个节点，很可能不久之后就会再次检查它。

这些方法只会在链表不太长的情况下才有效，数据项非常多的情况下，链表的效率太低，应选择其他的动态数据结构：

* 散列，维护一个链表的表格，并基于数据的值来确定应该使用哪个链表来存储节点；
* 二叉树，能够保证*近似最优性能*并且与所存储的数据项的*数量无关*。

如果性能和空间是需要重点考虑的因素，使用单链表；大多数情况，应该使用双链表，建立第二个指针的额外开销只会给性能带来很小的负担。

































